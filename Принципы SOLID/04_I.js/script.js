// --------------------- interface segregation principle (рус. Принцип Разделения Интерфейсов) ------------------------

// 1. Данный принцип, говорит нам о том, что  те классы, которые наследуются от базового класса
// если они не используют методы базового класса, то они не должны от них зависеть.

// Для начала, хотелось бы обозначить проблематику того, о чём нам этот принцип говорит:

class Animal {
    constructor(name) {
        this.name = name;
    }

    // Что умеют делать животные? Они умеют: гулять, плавать,  летать.
    walk() {
        console.log(`${this.name} умеет ходить !`);
    }

    swim() {
        console.log(`${this.name} умеет плавать !`);
    }

    fly() {
        console.log(`${this.name} умеет летать !`);
    }
}
// Вот, что умеет наш абстрактный класс Animal

// Теперь, создадим классы, которые будут наследоваться от животного

class Dog extends Animal {
    fly() {
        return null;
    }
}

class Eagle extends Animal {
    swim() {
        return null;
    }
}

class Whale extends Animal {
    fly() {
        return null;
    }

    walk() {
        return null;
    }
}

const dog = new Dog('Спайк');
dog.walk(); // Спайк умеет ходить !
dog.swim(); // Спайк умеет плавать !
// Однако, Спайк не всемогущий. И вызов метода fly() в этом случае неуместен.
// Поэтому нам нужно модифицировать класс Dog таким образом: fly() {return null;}
dog.fly(); // Этот метод не вывелся в консоль. Отлично !

const eagle = new Eagle('Хабиб');
eagle.fly(); // Хабиб умеет летать !
eagle.swim(); // Этот метод не вывелся в консоль. Отлично !
eagle.walk(); // Хабиб умеет ходить !

const whale = new Whale('Эскобар');
whale.fly(); // Этот метод не вывелся в консоль. Отлично !
whale.walk(); // Этот метод не вывелся в консоль. Отлично !
whale.swim(); // Эскобар умеет плавать !

// На текущий момент, наше приложение ведёт себя корректно. 
// Однако, наш класс Animal(от которого мы наследуемся) содержит в себе лишние элементы
// т.к он слишком обобщён, соответсвенно нам приходится отменять лишние методы, а это лишний функционал.
// В больших приложениях, из-за этого могут быть проблемы .

//--- Избежать этой проблемы в JS мы можем с помощью Composition API (Это связано не только с Vue.js. Это общий концепт)

class Animal2 {
    constructor(name) {
        this.name = name;
    }
}
// Но теперь, мы не описываем базовые методы в классе Animal (В этом примере Animal2), т.е мы оставим наследование

// Далее создадим несколько объектов.

// Объект, который будет добавлять свойство плавания
const swimmer = {
    swim() {
        console.log(`${this.name} умеет плавать !`);
    }
};

// Объект, который будет добавлять свойство полёта
const flier = {
    fly() {
        console.log(`${this.name} умеет летать !`);
    }
};

// Объект, который будет добавлять свойство ходьбы
const walker = {
    walk() {
        console.log(`${this.name} умеет ходить !`);
    }
};

class Dog2 extends Animal2 {}
class Eagle2 extends Animal2 {}
class Whale2 extends Animal2 {}

Object.assign(Dog2.prototype, swimmer, walker);
Object.assign(Eagle2.prototype, flier, walker);
Object.assign(Whale2.prototype, swimmer);

const dog2 = new Dog2('Спайк');
dog2.walk(); // Спайк умеет ходить !
dog2.swim(); // Спайк умеет плавать !
// dog2.fly(); // Этот метод мы не указываем,т.к в Dog2, мы не добавляли это поведение. В противном случае выдаст ошибку

const eagle2 = new Eagle2('Хабиб');
eagle2.fly(); // Хабиб умеет летать !
// eagle2.swim(); // Аналогично с примером выше
eagle2.walk(); // Хабиб умеет ходить !

const whale2 = new Whale2('Эскобар');
// whale2.fly(); // Аналогично с примером выше
// whale2.walk(); // Аналогично с примером выше
whale2.swim(); // Эскобар умеет плавать !

// --- Теперь наше приложение работает корректно. Т.е у тех классов, которые мы создали и наследовали от базового класса
// нет лишних элементов поведения 